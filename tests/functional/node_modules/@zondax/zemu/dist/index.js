"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.DeviceModel = exports.StartOptions = exports.DEFAULT_START_OPTIONS = void 0;
/** ******************************************************************************
 *  (c) 2020 Zondax GmbH
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
var pngjs_1 = __importDefault(require("pngjs"));
var fs_extra_1 = __importDefault(require("fs-extra"));
var sleep_1 = __importDefault(require("sleep"));
var get_port_1 = __importDefault(require("get-port"));
var axios_1 = __importDefault(require("axios"));
var axios_retry_1 = __importDefault(require("axios-retry"));
// @ts-ignore
var hw_transport_http_1 = __importDefault(require("@ledgerhq/hw-transport-http"));
// @ts-ignore
var elfy_1 = __importDefault(require("elfy"));
// @ts-ignore
var grpc_1 = __importDefault(require("./grpc"));
var constants_1 = require("./constants");
var emulator_1 = __importDefault(require("./emulator"));
var Resolve = require('path').resolve;
var rndstr = require('randomstring');
exports.DEFAULT_START_OPTIONS = {
    model: constants_1.DEFAULT_MODEL,
    logging: false,
    X11: false,
    custom: '',
    startDelay: constants_1.DEFAULT_START_DELAY,
    pressDelay: constants_1.DEFAULT_KEY_DELAY,
    startText: 'Ready'
};
var StartOptions = /** @class */ (function () {
    function StartOptions() {
        this.model = 'nanos';
        this.logging = false;
        this.X11 = false;
        this.custom = '';
        this.startDelay = constants_1.DEFAULT_START_DELAY;
        this.startText = 'Ready';
    }
    return StartOptions;
}());
exports.StartOptions = StartOptions;
var DeviceModel = /** @class */ (function () {
    function DeviceModel() {
    }
    return DeviceModel;
}());
exports.DeviceModel = DeviceModel;
var Zemu = /** @class */ (function () {
    function Zemu(elfPath, libElfs, host, desiredTransportPort, desiredSpeculosApiPort) {
        if (libElfs === void 0) { libElfs = {}; }
        if (host === void 0) { host = constants_1.DEFAULT_HOST; }
        this.transportProtocol = 'http';
        this.host = host;
        this.desiredTransportPort = desiredTransportPort;
        this.desiredSpeculosApiPort = desiredSpeculosApiPort;
        this.elfPath = elfPath;
        this.libElfs = libElfs;
        this.mainMenuSnapshot = null;
        this.vncSession = null;
        if (this.elfPath == null) {
            throw new Error('elfPath cannot be null!');
        }
        if (!fs_extra_1["default"].existsSync(this.elfPath)) {
            throw new Error('elf file was not found! Did you compile?');
        }
        Object.keys(libElfs).forEach(function (libName) {
            if (!fs_extra_1["default"].existsSync(libElfs[libName])) {
                throw new Error('lib elf file was not found! Did you compile?');
            }
        });
        var containerName = constants_1.BASE_NAME + rndstr.generate(5);
        this.emuContainer = new emulator_1["default"](this.elfPath, this.libElfs, constants_1.DEFAULT_EMU_IMG, containerName);
    }
    Zemu.prototype.getSession = function () {
        return this.vncSession;
    };
    Zemu.saveRGBA2Png = function (rect, filename) {
        var png = new pngjs_1["default"].PNG({
            width: rect.width,
            height: rect.height
        });
        png.data = rect.data.slice();
        var buffer = pngjs_1["default"].PNG.sync.write(png, { colorType: 6 });
        fs_extra_1["default"].writeFileSync(filename, buffer);
    };
    Zemu.LoadPng2RGB = function (filename) {
        var tmpBuffer = fs_extra_1["default"].readFileSync(filename);
        return pngjs_1["default"].PNG.sync.read(tmpBuffer);
    };
    Zemu.delay = function (v) {
        if (v) {
            sleep_1["default"].msleep(v);
        }
        else {
            sleep_1["default"].msleep(constants_1.DEFAULT_KEY_DELAY);
        }
    };
    Zemu.sleep = function (ms) {
        return new Promise(function (resolve) { return setTimeout(resolve, ms); });
    };
    Zemu.delayedPromise = function (p, delay) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.race([
                            p,
                            new Promise(function (resolve) {
                                setTimeout(resolve, delay);
                            }),
                        ])];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.stopAllEmuContainers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var timer;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        timer = setTimeout(function () {
                            console.log('Could not kill all containers before timeout!');
                            process.exit(1);
                        }, constants_1.KILL_TIMEOUT);
                        return [4 /*yield*/, emulator_1["default"].killContainerByName(constants_1.BASE_NAME)];
                    case 1:
                        _a.sent();
                        clearTimeout(timer);
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.checkAndPullImage = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, emulator_1["default"].checkAndPullImage(constants_1.DEFAULT_EMU_IMG)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.checkElf = function (model, elfPath) {
        var elfCodeNanoS = 0xc0d00001;
        var elfCodeNanoX = 0xc0de0001;
        var elfApp = fs_extra_1["default"].readFileSync(elfPath);
        var elfInfo = elfy_1["default"].parse(elfApp);
        if (elfInfo.entry !== elfCodeNanoS && elfInfo.entry !== elfCodeNanoX) {
            throw new Error('Are you sure is a Nano S/X app ?');
        }
        // FIXME: SDK2.0 entry points have changed
    };
    Zemu.prototype.start = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var e, _b, e_1;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.startOptions = options;
                        this.log("Checking ELF");
                        Zemu.checkElf((_a = this.startOptions.model) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MODEL, this.elfPath);
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 9, , 10]);
                        return [4 /*yield*/, Zemu.stopAllEmuContainers()];
                    case 2:
                        _c.sent();
                        if (!(!this.transportPort || !this.speculosApiPort)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getPortsToListen()];
                    case 3:
                        _c.sent();
                        _c.label = 4;
                    case 4:
                        if (!this.transportPort || !this.speculosApiPort) {
                            e = new Error("The Speculos API port or/and transport port couldn't be reserved");
                            this.log("[ZEMU] " + e);
                            throw e;
                        }
                        this.log("Starting Container");
                        return [4 /*yield*/, this.emuContainer.runContainer(__assign(__assign({}, this.startOptions), { transportPort: this.transportPort.toString(), speculosApiPort: this.speculosApiPort.toString() }))];
                    case 5:
                        _c.sent();
                        this.log("Started Container");
                        // eslint-disable-next-liwaine func-names
                        return [4 /*yield*/, this.connect()["catch"](function (error) {
                                _this.log("" + error);
                                _this.close();
                                throw error;
                            })];
                    case 6:
                        // eslint-disable-next-liwaine func-names
                        _c.sent();
                        this.log("Get initial snapshot");
                        // Captures main screen
                        return [4 /*yield*/, this.waitForText(this.startOptions.startText)];
                    case 7:
                        // Captures main screen
                        _c.sent();
                        _b = this;
                        return [4 /*yield*/, this.snapshot()];
                    case 8:
                        _b.mainMenuSnapshot = _c.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        e_1 = _c.sent();
                        this.log("[ZEMU] " + e_1);
                        throw e_1;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.connect = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var waitDelay, transport_url, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        waitDelay = (_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.startDelay) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_START_DELAY;
                        this.log("Wait for " + waitDelay + " ms");
                        Zemu.delay(waitDelay);
                        transport_url = this.transportProtocol + "://" + this.host + ":" + this.transportPort;
                        // Here it should be "StaticTransport" type, in order to be able to use the static method "open". That method belogs to StaticTransport
                        // https://github.com/LedgerHQ/ledgerjs/blob/0ec9a60fe57d75dff26a69c213fd824aa321231c/packages/hw-transport-http/src/withStaticURLs.ts#L89
                        _c = this;
                        return [4 /*yield*/, hw_transport_http_1["default"](transport_url).open(transport_url)];
                    case 1:
                        // Here it should be "StaticTransport" type, in order to be able to use the static method "open". That method belogs to StaticTransport
                        // https://github.com/LedgerHQ/ledgerjs/blob/0ec9a60fe57d75dff26a69c213fd824aa321231c/packages/hw-transport-http/src/withStaticURLs.ts#L89
                        _c.transport = _d.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.log = function (message) {
        var _a, _b;
        if ((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.logging) !== null && _b !== void 0 ? _b : false) {
            var currentTimestamp = new Date().toISOString().slice(11, 23);
            process.stdout.write("[ZEMU] " + currentTimestamp + ": " + message + "\n");
        }
    };
    Zemu.prototype.startGRPCServer = function (ip, port, options) {
        if (options === void 0) { options = {}; }
        this.grpcManager = new grpc_1["default"](ip, port, options, this.transport);
        this.grpcManager.startServer();
    };
    Zemu.prototype.stopGRPCServer = function () {
        if (this.grpcManager) {
            this.grpcManager.stopServer();
        }
    };
    Zemu.prototype.close = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.log('Close');
                        return [4 /*yield*/, this.emuContainer.stop()];
                    case 1:
                        _a.sent();
                        this.stopGRPCServer();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.getTransport = function () {
        if (!this.transport)
            throw new Error('Transport is not loaded.');
        return this.transport;
    };
    Zemu.prototype.getWindowRect = function () {
        var _a, _b, _c, _d;
        switch ((_b = (_a = this.startOptions) === null || _a === void 0 ? void 0 : _a.model) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_MODEL) {
            case 'nanos':
                return constants_1.WINDOW_S;
            case 'nanox':
                return constants_1.WINDOW_X;
        }
        throw "model " + ((_d = (_c = this.startOptions) === null || _c === void 0 ? void 0 : _c.model) !== null && _d !== void 0 ? _d : constants_1.DEFAULT_MODEL) + " not recognized";
    };
    Zemu.prototype.fetchSnapshot = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Exponential back-off retry delay between requests
                        axios_retry_1["default"](axios_1["default"], { retryDelay: axios_retry_1["default"].exponentialDelay });
                        return [4 /*yield*/, axios_1["default"]({
                                method: 'GET',
                                url: url,
                                responseType: 'arraybuffer'
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Zemu.prototype.saveSnapshot = function (arrayBuffer, filePath) {
        fs_extra_1["default"].writeFileSync(filePath, Buffer.from(arrayBuffer), 'binary');
    };
    Zemu.prototype.convertBufferToPNG = function (arrayBuffer) {
        return pngjs_1["default"].PNG.sync.read(Buffer.from(arrayBuffer));
    };
    Zemu.prototype.snapshot = function (filename) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var snapshotUrl, response, modelWindow;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        snapshotUrl = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/screenshot';
                        return [4 /*yield*/, this.fetchSnapshot(snapshotUrl)];
                    case 1:
                        response = _b.sent();
                        modelWindow = this.getWindowRect();
                        if (filename) {
                            this.saveSnapshot(response.data, filename);
                        }
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                var rect = {
                                    width: modelWindow.width,
                                    height: modelWindow.height,
                                    data: response.data
                                };
                                resolve(rect);
                            })];
                }
            });
        });
    };
    Zemu.prototype.getMainMenuSnapshot = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.mainMenuSnapshot];
            });
        });
    };
    Zemu.prototype.waitUntilScreenIsNot = function (screen, timeout) {
        if (timeout === void 0) { timeout = 10000; }
        return __awaiter(this, void 0, void 0, function () {
            var start, inputSnapshotBufferHex, _a, currentSnapshotBufferHex, _b, currentTime, elapsed, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        start = new Date();
                        _a = this.convertBufferToPNG;
                        return [4 /*yield*/, screen];
                    case 1:
                        inputSnapshotBufferHex = _a.apply(this, [(_d.sent()).data]);
                        _b = this.convertBufferToPNG;
                        return [4 /*yield*/, this.snapshot()];
                    case 2:
                        currentSnapshotBufferHex = _b.apply(this, [(_d.sent()).data]);
                        this.log("Wait for screen change");
                        _d.label = 3;
                    case 3:
                        if (!inputSnapshotBufferHex.data.equals(currentSnapshotBufferHex.data)) return [3 /*break*/, 6];
                        currentTime = new Date();
                        elapsed = currentTime.getTime() - start.getTime();
                        if (elapsed > timeout) {
                            throw "Timeout waiting for screen to change (" + timeout + " ms)";
                        }
                        return [4 /*yield*/, Zemu.delay(500)];
                    case 4:
                        _d.sent();
                        this.log("Check [" + elapsed + "ms]");
                        _c = this.convertBufferToPNG;
                        return [4 /*yield*/, this.snapshot()];
                    case 5:
                        currentSnapshotBufferHex = _c.apply(this, [(_d.sent()).data]);
                        return [3 /*break*/, 3];
                    case 6:
                        this.log("Screen changed");
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.formatIndexString = function (i) {
        return ("" + i).padStart(5, '0');
    };
    Zemu.prototype.navigateAndCompareSnapshots = function (path, testcaseName, clickSchedule) {
        return __awaiter(this, void 0, void 0, function () {
            var snapshotPrefixGolden, snapshotPrefixTmp, imageIndex, filename, i, value, j, j, j, img1, img2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        snapshotPrefixGolden = Resolve(path + "/snapshots/" + testcaseName);
                        snapshotPrefixTmp = Resolve(path + "/snapshots-tmp/" + testcaseName);
                        fs_extra_1["default"].ensureDirSync(snapshotPrefixGolden);
                        fs_extra_1["default"].ensureDirSync(snapshotPrefixTmp);
                        this.log("golden      " + snapshotPrefixGolden);
                        this.log("tmp         " + snapshotPrefixTmp);
                        imageIndex = 0;
                        filename = snapshotPrefixTmp + "/" + this.formatIndexString(imageIndex) + ".png";
                        this.log("---------------------------");
                        this.log("Start        " + filename);
                        return [4 /*yield*/, this.snapshot(filename)];
                    case 1:
                        _a.sent();
                        this.log("Instructions " + clickSchedule);
                        i = 0;
                        _a.label = 2;
                    case 2:
                        if (!(i < clickSchedule.length)) return [3 /*break*/, 14];
                        value = clickSchedule[i];
                        if (!(value == 0)) return [3 /*break*/, 4];
                        imageIndex += 1;
                        filename = snapshotPrefixTmp + "/" + this.formatIndexString(imageIndex) + ".png";
                        return [4 /*yield*/, this.clickBoth("" + filename, true)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 13];
                    case 4:
                        if (!(value < 0)) return [3 /*break*/, 9];
                        j = 0;
                        _a.label = 5;
                    case 5:
                        if (!(j < -value)) return [3 /*break*/, 8];
                        imageIndex += 1;
                        filename = snapshotPrefixTmp + "/" + this.formatIndexString(imageIndex) + ".png";
                        return [4 /*yield*/, this.clickLeft(filename)];
                    case 6:
                        _a.sent();
                        _a.label = 7;
                    case 7:
                        j += 1;
                        return [3 /*break*/, 5];
                    case 8: return [3 /*break*/, 13];
                    case 9:
                        j = 0;
                        _a.label = 10;
                    case 10:
                        if (!(j < value)) return [3 /*break*/, 13];
                        imageIndex += 1;
                        filename = snapshotPrefixTmp + "/" + this.formatIndexString(imageIndex) + ".png";
                        return [4 /*yield*/, this.clickRight(filename)];
                    case 11:
                        _a.sent();
                        _a.label = 12;
                    case 12:
                        j += 1;
                        return [3 /*break*/, 10];
                    case 13:
                        i++;
                        return [3 /*break*/, 2];
                    case 14:
                        ////////////////////
                        this.log("Start comparison");
                        for (j = 0; j < imageIndex + 1; j += 1) {
                            this.log("Checked     " + snapshotPrefixTmp + "/" + this.formatIndexString(j) + ".png");
                            img1 = Zemu.LoadPng2RGB(snapshotPrefixTmp + "/" + this.formatIndexString(j) + ".png");
                            img2 = Zemu.LoadPng2RGB(snapshotPrefixGolden + "/" + this.formatIndexString(j) + ".png");
                            if (!img1.data.equals(img2.data)) {
                                throw new Error("Image [" + this.formatIndexString(j) + "] do not match!");
                            }
                        }
                        return [2 /*return*/, true];
                }
            });
        });
    };
    Zemu.prototype.compareSnapshotsAndAccept = function (path, testcaseName, snapshotCount, backClickCount) {
        if (backClickCount === void 0) { backClickCount = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var instructions;
            return __generator(this, function (_a) {
                instructions = [];
                if (snapshotCount > 0)
                    instructions.push(snapshotCount);
                if (backClickCount > 0) {
                    instructions.push(-backClickCount);
                    instructions.push(backClickCount);
                }
                instructions.push(0);
                return [2 /*return*/, this.navigateAndCompareSnapshots(path, testcaseName, instructions)];
            });
        });
    };
    Zemu.prototype.getEvents = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var eventsUrl, data, error_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        axios_retry_1["default"](axios_1["default"], { retryDelay: axios_retry_1["default"].exponentialDelay });
                        eventsUrl = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/events';
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, axios_1["default"].get(eventsUrl)];
                    case 2:
                        data = (_b.sent()).data;
                        return [2 /*return*/, data['events']];
                    case 3:
                        error_1 = _b.sent();
                        return [2 /*return*/, []];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.deleteEvents = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var events, response;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        events = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/events';
                        return [4 /*yield*/, axios_1["default"]({
                                method: 'DELETE',
                                url: events
                            })];
                    case 1:
                        response = _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.waitScreenChange = function (timeout) {
        if (timeout === void 0) { timeout = 5000; }
        return __awaiter(this, void 0, void 0, function () {
            var start, prev_events_qty, current_events_qty, currentTime, elapsed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = new Date();
                        return [4 /*yield*/, this.getEvents()];
                    case 1:
                        prev_events_qty = (_a.sent()).length;
                        current_events_qty = prev_events_qty;
                        this.log("Wait for screen change");
                        _a.label = 2;
                    case 2:
                        if (!(prev_events_qty === current_events_qty)) return [3 /*break*/, 5];
                        currentTime = new Date();
                        elapsed = currentTime.getTime() - start.getTime();
                        if (elapsed > timeout) {
                            throw "Timeout waiting for screen to change (" + timeout + " ms)";
                        }
                        return [4 /*yield*/, Zemu.delay(500)];
                    case 3:
                        _a.sent();
                        this.log("Check [" + elapsed + "ms]");
                        return [4 /*yield*/, this.getEvents()];
                    case 4:
                        current_events_qty = (_a.sent()).length;
                        return [3 /*break*/, 2];
                    case 5:
                        this.log("Screen changed");
                        return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.waitForText = function (text, timeout) {
        if (timeout === void 0) { timeout = 5000; }
        return __awaiter(this, void 0, void 0, function () {
            var start, found, currentTime, elapsed, events;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = new Date();
                        found = false;
                        _a.label = 1;
                    case 1:
                        if (!!found) return [3 /*break*/, 4];
                        currentTime = new Date();
                        elapsed = currentTime.getTime() - start.getTime();
                        if (elapsed > timeout) {
                            throw "Timeout waiting for text (" + text + ")";
                        }
                        return [4 /*yield*/, this.getEvents()];
                    case 2:
                        events = _a.sent();
                        events.forEach(function (element) {
                            if (element['text'].includes(text)) {
                                found = true;
                            }
                        });
                        return [4 /*yield*/, Zemu.delay(500)];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Zemu.prototype.clickLeft = function (filename) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var leftClickUrl, payload;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        leftClickUrl = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/button/left';
                        payload = { action: 'press-and-release' };
                        return [4 /*yield*/, axios_1["default"].post(leftClickUrl, payload)];
                    case 1:
                        _b.sent();
                        this.log("Click Left  " + filename);
                        return [2 /*return*/, this.snapshot(filename)];
                }
            });
        });
    };
    Zemu.prototype.clickRight = function (filename) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var rightClickUrl, payload;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        rightClickUrl = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/button/right';
                        payload = { action: 'press-and-release' };
                        return [4 /*yield*/, axios_1["default"].post(rightClickUrl, payload)];
                    case 1:
                        _b.sent();
                        this.log("Click Right " + filename);
                        return [2 /*return*/, this.snapshot(filename)];
                }
            });
        });
    };
    Zemu.prototype.clickBoth = function (filename, waitForScreenUpdate) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var previousScreen, bothClickUrl, payload, watchdog, currentScreen;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!waitForScreenUpdate) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.snapshot()];
                    case 1:
                        previousScreen = _b.sent();
                        _b.label = 2;
                    case 2:
                        bothClickUrl = 'http://localhost:' + ((_a = this.speculosApiPort) === null || _a === void 0 ? void 0 : _a.toString()) + '/button/both';
                        payload = { action: 'press-and-release' };
                        return [4 /*yield*/, axios_1["default"].post(bothClickUrl, payload)];
                    case 3:
                        _b.sent();
                        this.log("Click Both  " + filename);
                        if (!waitForScreenUpdate) return [3 /*break*/, 8];
                        watchdog = 5000;
                        return [4 /*yield*/, this.snapshot()];
                    case 4:
                        currentScreen = _b.sent();
                        _b.label = 5;
                    case 5:
                        if (!currentScreen.data.equals(previousScreen.data)) return [3 /*break*/, 8];
                        this.log("sleep");
                        return [4 /*yield*/, Zemu.delay(100)];
                    case 6:
                        _b.sent();
                        watchdog -= 100;
                        if (watchdog <= 0)
                            throw 'Timeout waiting for screen update';
                        return [4 /*yield*/, this.snapshot()];
                    case 7:
                        currentScreen = _b.sent();
                        return [3 /*break*/, 5];
                    case 8: return [2 /*return*/, this.snapshot(filename)];
                }
            });
        });
    };
    Zemu.prototype.getPortsToListen = function () {
        return __awaiter(this, void 0, void 0, function () {
            var transportPort, speculosApiPort;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, get_port_1["default"]({ port: this.desiredTransportPort })];
                    case 1:
                        transportPort = _a.sent();
                        return [4 /*yield*/, get_port_1["default"]({ port: this.desiredSpeculosApiPort })];
                    case 2:
                        speculosApiPort = _a.sent();
                        this.transportPort = transportPort;
                        this.speculosApiPort = speculosApiPort;
                        return [2 /*return*/];
                }
            });
        });
    };
    return Zemu;
}());
exports["default"] = Zemu;
